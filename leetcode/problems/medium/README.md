# Leetcode DocStrings

This README file was autogenerated with readme_generator.py.

# Contents
- [0103_binary_tree_zigzag_level_order_traversal](#0103_binary_tree_zigzag_level_order_traversalpy)
- [0199_binary_tree_right_side_view](#0199_binary_tree_right_side_viewpy)
- [0200_number_of_islands](#0200_number_of_islandspy)
- [0236_lowest_common_ancestor_of_a_binary_tree](#0236_lowest_common_ancestor_of_a_binary_treepy)
- [0323_number_of_connected_components_in_an_undirected_graph](#0323_number_of_connected_components_in_an_undirected_graphpy)
- [0515_find_largest_value_in_each_tree_row](#0515_find_largest_value_in_each_tree_rowpy)
- [0547_number_of_provinces](#0547_number_of_provincespy)
- [0695_max_area_of_island](#0695_max_area_of_islandpy)
- [0841_keys_and_rooms](#0841_keys_and_roomspy)
- [1004_max_consecutive_ones_iii](#1004_max_consecutive_ones_iiipy)
- [1026_maximum_difference_between_node_and_ancestory](#1026_maximum_difference_between_node_and_ancestorypy)
- [1091_shortest_path_in_binary_matrix](#1091_shortest_path_in_binary_matrixpy)
- [1302_deepest_leaves_sum](#1302_deepest_leaves_sumpy)
- [1448_count_good_nodes_in_binary_tree](#1448_count_good_nodes_in_binary_treepy)
- [1466_reorder_routes_to_make_all_paths_lead_to_city_zero](#1466_reorder_routes_to_make_all_paths_lead_to_city_zeropy)
- [1557_minimum_number_of_vertices_to_reach_all_nodes](#1557_minimum_number_of_vertices_to_reach_all_nodespy)
- [2368_reachable_nodes_with_restrictions](#2368_reachable_nodes_with_restrictionspy)

# 0103_binary_tree_zigzag_level_order_traversal.py

**File Name**: 0103_binary_tree_zigzag_level_order_traversal.py

**Key Point**:  Return a forward or reversed list of node values, alternative per level of the tree. 

**Link**: [binary tree zigzag level order traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/ )

**Method**: Use BFS. Store a list of values per level of the tree. If the level is odd, add that list to the list of answers. If it is even, add the reversed list instead. 

**Returns**: List of node values in zig zag order or an empty list if the root is None.


[Return to Top](#contents)

---

# 0199_binary_tree_right_side_view.py

**File Name**: 0199_binary_tree_right_side_view.py

**Key Point**:  Return the rightmost node at each level of the binary tree. 

**Link**: [binary tree right side view](https://leetcode.com/problems/binary-tree-right-side-view/description/ )

**Method**: Use BFS to traverse the tree. Hold the nodes of each level in a list. Append the value of the rightmost node to the list of answers. 

**Returns**: The values of the rightmost nodes in the tree or an empty list if the root is None.


[Return to Top](#contents)

---

# 0200_number_of_islands.py

**File Name**: 0200_number_of_islands.py

**Key Point**:  Explore the graph recursively, moving to adjacent cells if they: (1) have not been visited (2) have a value of "1". 

**Link**: [number of islands](https://leetcode.com/problems/number-of-islands/ )

**Method**: At each cell, check if the cell has been visited and if the value is "1". If so, explore adjacent cells recursively using the same methodology, marking encountered cells as visited. If not, skip to the next cell. 

**Returns**: Int representing the number of disconnected clusters of 1's in the grid (islands).


[Return to Top](#contents)

---

# 0236_lowest_common_ancestor_of_a_binary_tree.py

**File Name**: 0236_lowest_common_ancestor_of_a_binary_tree.py

**Key Point**:  Three cases: (1) Root is LCA, (2) LCA is on left subtree, (3) LCA is on right subtree. 

**Link**: [lowest common ancestor of a binary tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/ )

**Method**: Use DFS to split the tree into subtrees. Check for each of the three cases in each subtree. Note that a node can be its own descendent. Therefore, if a node matches either p or q descendents, then it is also the LCA. If one descendent is found in the left and right subtrees, each, then the root is the LCA (since it links the two subtrees). 

**Returns**: The LCA if it exists or None if it does not.


[Return to Top](#contents)

---

# 0323_number_of_connected_components_in_an_undirected_graph.py

**File Name**: 0323_number_of_connected_components_in_an_undirected_graph.py

**Key Point**:  Use DFS search and a hash set (seen) to track connected clusters or "islands" of nodes. 

**Link**: [number of connected components in an undirected graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/ )

**Method**: Build an adjacency list. Starting from first node, determine connected nodes using DFS. Add these nodes into seen. Count this is an "island". Move to next unseen node and repeat until no nodes remain. 

**Returns**: Int representing the number of "islands" or groups of connect nodes in a graph.


[Return to Top](#contents)

---

# 0515_find_largest_value_in_each_tree_row.py

**File Name**: 0515_find_largest_value_in_each_tree_row.py

**Key Point**:  Traverse the tree by level. Find the max value in every row. 

**Link**: [find largest value in each tree row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/ )

**Method**: Use BFS. Go level by level. At each level, keep track of the max value encountered. At each node, update the max value. At the end of each level, add the max value to the list of answers. 

**Returns**: The list of max node values per level or an empty list if the root is None.


[Return to Top](#contents)

---

# 0547_number_of_provinces.py

**File Name**: 0547_number_of_provinces.py

**Key Point**:  Use DFS and a hash set to track groups of visited provinces. 

**Link**: [number of provinces](https://leetcode.com/problems/number-of-provinces/ )

**Method**: For each node, use DFS to visit all connected neighbors. Track each visited neighbor in a hash set. Record each group of connected nodes as a province. 

**Returns**: Number of groups of directly connected nodes.


[Return to Top](#contents)

---

# 0695_max_area_of_island.py

**File Name**: 0695_max_area_of_island.py

**Key Point**:  Use DFS to track number of directly connected nodes (area) within each disjoint set of connected nodes (islands) in a 2D matrix, representing a map. 

**Link**: [max area of island](https://leetcode.com/problems/max-area-of-island/ )

**Method**: Use DFS. Iterate through the grid, checking if the element is equal to "1" and has not been previously visited. If so, use DFS to recursively explore all connected elements, tracking the number of connected elements (area). If the current area is larger than the max area, then record the current value as the new max. Track all visisted elements in a set. Repeat for all elements. 

**Returns**: Int representing the maximum number of directly connected elements in a group of connected elements in the grid.


[Return to Top](#contents)

---

# 0841_keys_and_rooms.py

**File Name**: 0841_keys_and_rooms.py

**Key Point**:  Treat input as an adjacency list and traverse using DFS. 

**Link**: [keys and rooms](https://leetcode.com/problems/keys-and-rooms/ )

**Method**: Build adjacency list from input. DFS from node 0. If number of rooms visited is equal to total number of rooms, then you can visit all rooms. 

**Returns**: True if can visit all rooms and False if not.


[Return to Top](#contents)

---

# 1004_max_consecutive_ones_iii.py

**File Name**: 1004_max_consecutive_ones_iii.py

**Key Point**:  Sliding window. Window size is determined by "k" allowed flipped zeros. 

**Link**: [max consecutive ones iii](https://leetcode.com/problems/max-consecutive-ones-iii/ )

**Method**: Increase window until max number of flipped zeroes is exceeded. Retract window from the left until number of flipped zeroes equals max. Increase window size and repeat until no numbers remain. 

**Returns**: Max number of consecutive 1's in the list.


[Return to Top](#contents)

---

# 1026_maximum_difference_between_node_and_ancestory.py

**File Name**: 1026_maximum_difference_between_node_and_ancestory.py

**Key Point**:  Key point: Keep track of min and max values for each path and calculate difference at the end. 

**Link**: [maximum difference between node and ancestory](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/ )

**Method**: Use DFS. Ancestor is just a predecessor node. Track min and max values for each pathway and calculate the difference at the end (running off the leaf node). 

**Returns**: int of the maximum difference between ancestors or 0 if root is None.


[Return to Top](#contents)

---

# 1091_shortest_path_in_binary_matrix.py

**File Name**: 1091_shortest_path_in_binary_matrix.py

**Key Point**:  Use BFS to determine the shortest path. 

**Link**: [shortest path in binary matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/ )

**Method**: Use BFS. Track number of steps as you add each connected node to the queue (each level has the same step). Track visited nodes in a set to prevent backtracking. Return the number of steps as soon as the bottom left node is reached. 

**Returns**: Int representing the length of the shortest path from the top left cell to the bottom right cell of the input grid.


[Return to Top](#contents)

---

# 1302_deepest_leaves_sum.py

**File Name**: 1302_deepest_leaves_sum.py

**Key Point**:  Return the sum of the nodes in the lowest level of the tree. 

**Link**: [deepest leaves sum](https://leetcode.com/problems/deepest-leaves-sum/description/ )

**Method**: Use BFS. If every node added to the queue does not have any children, then you are at the deepest level. Return the sum of the nodes. You can calculate it based on the queue or keep a running total. 

**Returns**: An int representing the sum of the nodes at the deepest level of the tree or 0 if the root is None.


[Return to Top](#contents)

---

# 1448_count_good_nodes_in_binary_tree.py

**File Name**: 1448_count_good_nodes_in_binary_tree.py

**Key Point**:  Track the current max node value. Update the answer at every node (whether condition is met). 

**Link**: [count good nodes in binary tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/ )

**Method**: Using DFS, traverse the tree. At each node, track the maximum node value encountered so far. Iterate answer if "good node" condition is met. Call method recursively for left and right subtrees. Return accumulated answer. 

**Returns**: Number of "good" nodes in the binary tree. A node is "good" if there are no nodes between it and the root with a greater value. The root is always a good node.


[Return to Top](#contents)

---

# 1466_reorder_routes_to_make_all_paths_lead_to_city_zero.py

**File Name**: 1466_reorder_routes_to_make_all_paths_lead_to_city_zero.py

**Key Point**:  Use DFS to traverse from city 0 to all other nodes and compare the path between nodes to the input. 

**Link**: [reorder routes to make all paths lead to city zero](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/ )

**Method**: Build an adjacency map from the input. Also build a set of directional edges (roads) between nodes (cities). Then use DFS to visit all nodes from city 0. Compare each edge to the edges within the set. If the edge exists, then the road is going in the right direction. If the edge does not exist, it needs to be swapped. 

**Returns**: Int representing the number of roads that need to have their direction swapped for all roads to lead city 0.


[Return to Top](#contents)

---

# 1557_minimum_number_of_vertices_to_reach_all_nodes.py

**File Name**: 1557_minimum_number_of_vertices_to_reach_all_nodes.py

**Key Point**:  Return a list of nodes without incoming edges. 

**Link**: [minimum number of vertices to reach all nodes](https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/ )

**Method**: This only works for DAG. Otherwise, we'd have to worry about a cycle. So there would be no node that isn't reachable by any other node. We're finding only a list of parents. They aren't reachable by any other nodes, so you need to include each parent to reach every other node. Initialize a list of size N to 0. Add 1 to list\[node\] for each incoming edge encountered. Return a list of nodes with no incoming edges. 

**Returns**: List of nodes with no incoming edges (parents).


[Return to Top](#contents)

---

# 2368_reachable_nodes_with_restrictions.py

**File Name**: 2368_reachable_nodes_with_restrictions.py

**Key Point**:  Use DFS to explore the part of the graph not blocked by restricted nodes. 

**Link**: [reachable nodes with restrictions](https://leetcode.com/problems/reachable-nodes-with-restrictions/ )

**Method**: Generate adjacency list from input Use DFS to explore the graph. Track visited nodes and (the set of) restricted nodes. Do not visit previously visited nodes or restricted nodes. Return number of nodes visited (will naturally be the max number). 

**Returns**: Int representing the maximum number of non restricted nodes that can be visited from the root.


[Return to Top](#contents)

---

