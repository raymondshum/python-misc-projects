# Leetcode DocStrings

This README file was autogenerated with readme_generator.py.

# Contents
- [0236_lowest_common_ancestor_of_a_binary_tree](#0236_lowest_common_ancestor_of_a_binary_treepy)
- [1004_max_consecutive_ones_iii](#1004_max_consecutive_ones_iiipy)
- [1448_count_good_nodes_in_binary_tree](#1448_count_good_nodes_in_binary_treepy)

# 0236_lowest_common_ancestor_of_a_binary_tree.py

**File Name**: 0236_lowest_common_ancestor_of_a_binary_tree.py

**Key Point**:  Three cases: (1) Root is LCA, (2) LCA is on left subtree, (3) LCA is on right subtree. 

**Link**: [lowest common ancestor of a binary tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/ )

**Method**: Use DFS to split the tree into subtrees. Check for each of the three cases in each subtree. Note that a node can be its own descendent. Therefore, if a node matches either p or q descendents, then it is also the LCA. If one descendent is found in the left and right subtrees, each, then the root is the LCA (since it links the two subtrees). 

**Returns**: The LCA if it exists or None if it does not.


[Return to Top](#contents)

---

# 1004_max_consecutive_ones_iii.py

**File Name**: 1004_max_consecutive_ones_iii.py

**Key Point**:  Sliding window. Window size is determined by "k" allowed flipped zeros. 

**Link**: [max consecutive ones iii](https://leetcode.com/problems/max-consecutive-ones-iii/ )

**Method**: Increase window until max number of flipped zeroes is exceeded. Retract window from the left until number of flipped zeroes equals max. Increase window size and repeat until no numbers remain. 

**Returns**: Max number of consecutive 1's in the list.


[Return to Top](#contents)

---

# 1448_count_good_nodes_in_binary_tree.py

**File Name**: 1448_count_good_nodes_in_binary_tree.py

**Key Point**:  Track the current max node value. Update the answer at every node (whether condition is met). 

**Link**: [count good nodes in binary tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/ )

**Method**: Using DFS, traverse the tree. At each node, track the maximum node value encountered so far. Iterate answer if "good node" condition is met. Call method recursively for left and right subtrees. Return accumulated answer. 

**Returns**: Number of "good" nodes in the binary tree. A node is "good" if there are no nodes between it and the root with a greater value. The root is always a good node.


[Return to Top](#contents)

---

