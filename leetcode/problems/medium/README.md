# Leetcode DocStrings

This README file was autogenerated with readme_generator.py.

# Contents
- [0103_binary_tree_zigzag_level_order_traversal](#0103_binary_tree_zigzag_level_order_traversalpy)
- [0199_binary_tree_right_side_view](#0199_binary_tree_right_side_viewpy)
- [0200_number_of_islands](#0200_number_of_islandspy)
- [0236_lowest_common_ancestor_of_a_binary_tree](#0236_lowest_common_ancestor_of_a_binary_treepy)
- [0515_find_largest_value_in_each_tree_row](#0515_find_largest_value_in_each_tree_rowpy)
- [0547_number_of_provinces](#0547_number_of_provincespy)
- [1004_max_consecutive_ones_iii](#1004_max_consecutive_ones_iiipy)
- [1026_maximum_difference_between_node_and_ancestory](#1026_maximum_difference_between_node_and_ancestorypy)
- [1302_deepest_leaves_sum](#1302_deepest_leaves_sumpy)
- [1448_count_good_nodes_in_binary_tree](#1448_count_good_nodes_in_binary_treepy)

# 0103_binary_tree_zigzag_level_order_traversal.py

**File Name**: 0103_binary_tree_zigzag_level_order_traversal.py

**Key Point**:  Return a forward or reversed list of node values, alternative per level of the tree. 

**Link**: [binary tree zigzag level order traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/ )

**Method**: Use BFS. Store a list of values per level of the tree. If the level is odd, add that list to the list of answers. If it is even, add the reversed list instead. 

**Returns**: List of node values in zig zag order or an empty list if the root is None.


[Return to Top](#contents)

---

# 0199_binary_tree_right_side_view.py

**File Name**: 0199_binary_tree_right_side_view.py

**Key Point**:  Return the rightmost node at each level of the binary tree. 

**Link**: [binary tree right side view](https://leetcode.com/problems/binary-tree-right-side-view/description/ )

**Method**: Use BFS to traverse the tree. Hold the nodes of each level in a list. Append the value of the rightmost node to the list of answers. 

**Returns**: The values of the rightmost nodes in the tree or an empty list if the root is None.


[Return to Top](#contents)

---

# 0200_number_of_islands.py

**File Name**: 0200_number_of_islands.py

**Key Point**:  Explore the graph recursively, moving to adjacent cells if they: (1) have not been visited (2) have a value of "1". 

**Link**: [number of islands](https://leetcode.com/problems/number-of-islands/ )

**Method**: At each cell, check if the cell has been visited and if the value is "1". If so, explore adjacent cells recursively using the same methodology, marking encountered cells as visited. If not, skip to the next cell. 

**Returns**: Int representing the number of disconnected clusters of 1's in the grid (islands).


[Return to Top](#contents)

---

# 0236_lowest_common_ancestor_of_a_binary_tree.py

**File Name**: 0236_lowest_common_ancestor_of_a_binary_tree.py

**Key Point**:  Three cases: (1) Root is LCA, (2) LCA is on left subtree, (3) LCA is on right subtree. 

**Link**: [lowest common ancestor of a binary tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/ )

**Method**: Use DFS to split the tree into subtrees. Check for each of the three cases in each subtree. Note that a node can be its own descendent. Therefore, if a node matches either p or q descendents, then it is also the LCA. If one descendent is found in the left and right subtrees, each, then the root is the LCA (since it links the two subtrees). 

**Returns**: The LCA if it exists or None if it does not.


[Return to Top](#contents)

---

# 0515_find_largest_value_in_each_tree_row.py

**File Name**: 0515_find_largest_value_in_each_tree_row.py

**Key Point**:  Traverse the tree by level. Find the max value in every row. 

**Link**: [find largest value in each tree row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/ )

**Method**: Use BFS. Go level by level. At each level, keep track of the max value encountered. At each node, update the max value. At the end of each level, add the max value to the list of answers. 

**Returns**: The list of max node values per level or an empty list if the root is None.


[Return to Top](#contents)

---

# 0547_number_of_provinces.py

**File Name**: 0547_number_of_provinces.py

**Key Point**:  Use DFS and a hash set to track groups of visited provinces. 

**Link**: [number of provinces](https://leetcode.com/problems/number-of-provinces/ )

**Method**: For each node, use DFS to visit all connected neighbors. Track each visited neighbor in a hash set. Record each group of connected nodes as a province. 

**Returns**: Number of groups of directly connected nodes.


[Return to Top](#contents)

---

# 1004_max_consecutive_ones_iii.py

**File Name**: 1004_max_consecutive_ones_iii.py

**Key Point**:  Sliding window. Window size is determined by "k" allowed flipped zeros. 

**Link**: [max consecutive ones iii](https://leetcode.com/problems/max-consecutive-ones-iii/ )

**Method**: Increase window until max number of flipped zeroes is exceeded. Retract window from the left until number of flipped zeroes equals max. Increase window size and repeat until no numbers remain. 

**Returns**: Max number of consecutive 1's in the list.


[Return to Top](#contents)

---

# 1026_maximum_difference_between_node_and_ancestory.py

**File Name**: 1026_maximum_difference_between_node_and_ancestory.py

**Key Point**:  Key point: Keep track of min and max values for each path and calculate difference at the end. 

**Link**: [maximum difference between node and ancestory](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/ )

**Method**: Use DFS. Ancestor is just a predecessor node. Track min and max values for each pathway and calculate the difference at the end (running off the leaf node). 

**Returns**: int of the maximum difference between ancestors or 0 if root is None.


[Return to Top](#contents)

---

# 1302_deepest_leaves_sum.py

**File Name**: 1302_deepest_leaves_sum.py

**Key Point**:  Return the sum of the nodes in the lowest level of the tree. 

**Link**: [deepest leaves sum](https://leetcode.com/problems/deepest-leaves-sum/description/ )

**Method**: Use BFS. If every node added to the queue does not have any children, then you are at the deepest level. Return the sum of the nodes. You can calculate it based on the queue or keep a running total. 

**Returns**: An int representing the sum of the nodes at the deepest level of the tree or 0 if the root is None.


[Return to Top](#contents)

---

# 1448_count_good_nodes_in_binary_tree.py

**File Name**: 1448_count_good_nodes_in_binary_tree.py

**Key Point**:  Track the current max node value. Update the answer at every node (whether condition is met). 

**Link**: [count good nodes in binary tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/ )

**Method**: Using DFS, traverse the tree. At each node, track the maximum node value encountered so far. Iterate answer if "good node" condition is met. Call method recursively for left and right subtrees. Return accumulated answer. 

**Returns**: Number of "good" nodes in the binary tree. A node is "good" if there are no nodes between it and the root with a greater value. The root is always a good node.


[Return to Top](#contents)

---

