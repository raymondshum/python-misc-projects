# Leetcode DocStrings

This README file was autogenerated with readme_generator.py.

# Contents
- [0001_two_sum](#0001_two_sumpy)
- [0020_valid_parenthesis](#0020_valid_parenthesispy)
- [0021_merge_two_sorted_lists](#0021_merge_two_sorted_listspy)
- [0035_search_insert_position](#0035_search_insert_positionpy)
- [0104_maximum_depth_of_binary_tree](#0104_maximum_depth_of_binary_treepy)
- [0121_best_time_to_buy_and_sell_stock](#0121_best_time_to_buy_and_sell_stockpy)
- [0206_reverse_linked_list](#0206_reverse_linked_listpy)
- [0226_invert_binary_tree](#0226_invert_binary_treepy)
- [0344_reverse_string](#0344_reverse_stringpy)
- [0643_maximum_average_subarray_i](#0643_maximum_average_subarray_ipy)
- [0704_binary_search](#0704_binary_searchpy)
- [0977_squares_of_a_sorted_array](#0977_squares_of_a_sorted_arraypy)

# 0001_two_sum.py

**File Name**: 0001_two_sum.py

**Key Point**: Use dictionary (hash map) to store results. 

**Link**: [two sum](https://leetcode.com/problems/two-sum/ )

**Method**: Iterates through the list. If (target - current_value) is not in the dictionary, we append its value and index. If it is in the dictionary, we can return the indicies of target and current_value. This is because its presence in the dictionary lets us know that we have already encountered and logged the second number necessary to reach the target value. 

**Returns**: List: [index1, index2] where nums[index1] + nums[index2] == target


[Return to Top](#contents)

---

# 0020_valid_parenthesis.py

**File Name**: 0020_valid_parenthesis.py

**Key Point**: Use a stack to store opening brackets. Pop to compare them to closing brackets. 

**Link**: [valid parenthesis](https://leetcode.com/problems/valid-parentheses/ )

**Method**: I chose to build a pattern dictionary to represent valid pairs of brackets. Opening brackets (dict keys) are push onto a stack. When a closing bracket is encountered, the stack is popped. The value of dict[opening_bracket] is compared to the encountered closing bracket. If there is a mismatch, then the function returns False. 

**Returns**: bool: True if string contains brackets in correct order. False if not.


[Return to Top](#contents)

---

# 0021_merge_two_sorted_lists.py

**File Name**: 0021_merge_two_sorted_lists.py

**Key Point**: Account for ragged edges (uneven lists). 

**Link**: [merge two sorted lists](https://leetcode.com/problems/merge-two-sorted-lists/ )

**Method**: Most of the logic is used to account for uneven lists. If either list is missing, the remaining is immediately returned. This method recursively compares each node from one list against the other. The until the base case (at least one null list) is reached. At each method call, the smaller of either node (or node from list1 if equal) is ultimately returned. 

**Returns**: ListNode: Head of merged List.


[Return to Top](#contents)

---

# 0035_search_insert_position.py

**File Name**: 0035_search_insert_position.py

**Key Point**: This is a binary search that estimates the index of a missing value rather than returning -1. 

**Link**: [search insert position](https://leetcode.com/problems/search-insert-position/ )

**Method**: Binary search algorithm. However, if the value is not found: 1) Midpoint is the last one calculated when start_index = end_index. 2) If the midpoint is < target, it means that the target should be in the next sequential index (start_index in my implementation). 3) Otherwise, it should be where the midpoint is (and the loop broke) 

**Returns**: int: Index number of value in the List or where it should be if it exists.


[Return to Top](#contents)

---

# 0104_maximum_depth_of_binary_tree.py

**File Name**: 0104_maximum_depth_of_binary_tree.py

**Key Point**: Use recursive DFS to get the max depth. 

**Link**: [maximum depth of binary tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/ )

**Method**: Recursive method. Starting at root, count each existing node until the furthest node is reached. Each recursive method call will only return the highest current count (1 or 0). All counts return up through the call stack. 

**Returns**: Int: Max depth of tree


[Return to Top](#contents)

---

# 0121_best_time_to_buy_and_sell_stock.py

**File Name**: 0121_best_time_to_buy_and_sell_stock.py

**Key Point**: Use two pointers. Left pointer tracks the lowest (buy) price. Right pointer always iterates. 

**Link**: [best time to buy and sell stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ )

**Method**: Start buy_pointer at the first index and sell_pointer at the second index. At each loop, calculate the current value (sell value - buy value). Memorize new max values. If buy pointer is > sell pointer, it should be moved. Sell pointer holds the current lowest value. Sell pointer should iterate at each loop (as if days are moving foward). 

**Returns**: int: Maximum difference between a sell value and buy value in the list of prices.


[Return to Top](#contents)

---

# 0206_reverse_linked_list.py

**File Name**: 0206_reverse_linked_list.py

**Key Point**: Current, next and prev hold the structure of the linked list as you are reversing the direction of the pointers. 

**Link**: [reverse linked list](https://leetcode.com/problems/reverse-linked-list/ )

**Method**: Current, next and prev hold the structure of the linked list as you are reversing the direction of the pointers. 

**Returns**: ListNode: Head of the reversed linked list.


[Return to Top](#contents)

---

# 0226_invert_binary_tree.py

**File Name**: 0226_invert_binary_tree.py

**Key Point**: Use a temp node to swap left and right nodes. 

**Link**: [invert binary tree](https://leetcode.com/problems/invert-binary-tree/submissions/ )

**Method**: Recursive method. For each node, return if its None. Else, swap the left and right nodes. Then call invert on the child nodes. 

**Returns**: Optional[TreeNode]: Head of inverted binary tree.


[Return to Top](#contents)

---

# 0344_reverse_string.py

**File Name**: 0344_reverse_string.py

**Key Point**:  Can either use stack or two pointers. Two pointers uses less memory. 

**Link**: [reverse string](https://leetcode.com/problems/reverse-string/ )

**Method**: Swap letters at both ends until pointers meet. 

**Returns**: Nothing. In place swap.


[Return to Top](#contents)

---

# 0643_maximum_average_subarray_i.py

**File Name**: 0643_maximum_average_subarray_i.py

**Key Point**:  Sliding window problem with fixed width "k". Maintain moving average. 

**Link**: [maximum average subarray i](https://leetcode.com/problems/maximum-average-subarray-i/ )

**Method**: See Key Point. 

**Returns**: float of maximum average


[Return to Top](#contents)

---

# 0704_binary_search.py

**File Name**: 0704_binary_search.py

**Key Point**: Cut the breadth of the search area in half at every iteration. 

**Link**: [binary search](https://leetcode.com/problems/binary-search/ )

**Method**: At each iteration of the loop, calculate a pivot (midpoint) that is between the two endpoints. Initially, the endpoints are the ends of the array. If the midpoint is larger than the target, then the next search area is the lower half of the array (and upper half if it is larger). This repeats until the value is found or the array is exhausted. 

**Returns**: int: index of the target number or -1 if it is not found.


[Return to Top](#contents)

---

# 0977_squares_of_a_sorted_array.py

**File Name**: 0977_squares_of_a_sorted_array.py

**Key Point**:  Two pointers. Maintain sorted order by comparing absolute values. 

**Link**: [squares of a sorted array](https://leetcode.com/problems/squares-of-a-sorted-array/ )

**Method**: Left pointer at bottom and right pointer at top. Pointers move towards each other. Largest abs value is placed into the array from top down. This maintains sorted order if negatives are present. 

**Returns**: Sorted array of ints of increasing value.


[Return to Top](#contents)

---

