# Leetcode DocStrings

This README file was autogenerated with readme_generator.py.

# 1_two_sum.py

**File Name**: 1_two_sum.py

**Key Point**: Use dictionary (hash map) to store results. 

**Link**: https://leetcode.com/problems/two-sum/ 

**Method**: Iterates through the list. If (target - current_value) is not in the dictionary, we append its value and index. If it is in the dictionary, we can return the indicies of target and current_value. This is because its presence in the dictionary lets us know that we have already encountered and logged the second number necessary to reach the target value. 

**Returns**: List: [index1, index2] where nums[index1] + nums[index2] == target

---

# 20_valid_parenthesis.py

**File Name**: 20_valid_parenthesis.py

**Key Point**: Use a stack to store opening brackets. Pop to compare them to closing brackets. 

**Link**: https://leetcode.com/problems/valid-parentheses/ 

**Method**: I chose to build a pattern dictionary to represent valid pairs of brackets. Opening brackets (dict keys) are push onto a stack. When a closing bracket is encountered, the stack is popped. The value of dict[opening_bracket] is compared to the encountered closing bracket. If there is a mismatch, then the function returns False. 

**Returns**: bool: True if string contains brackets in correct order. False if not.

---

# 21_merge_two_sorted_lists.py

**File Name**: 21_merge_two_sorted_lists.py

**Key Point**: Account for ragged edges (uneven lists). 

**Link**: https://leetcode.com/problems/merge-two-sorted-lists/ 

**Method**: Most of the logic is used to account for uneven lists. If either list is missing, the remaining is immediately returned. This method recursively compares each node from one list against the other. The until the base case (at least one null list) is reached. At each method call, the smaller of either node (or node from list1 if equal) is ultimately returned. 

**Returns**: ListNode: Head of merged List.

---

# 35_search_insert_position.py

**File Name**: 35_search_insert_position.py

**Key Point**: This is a binary search that estimates the index of a missing value rather than returning -1. 

**Link**: https://leetcode.com/problems/search-insert-position/ 

**Method**: Binary search algorithm. However, if the value is not found: 1) Midpoint is the last one calculated when start_index = end_index. 2) If the midpoint is < target, it means that the target should be in the next sequential index (start_index in my implementation). 3) Otherwise, it should be where the midpoint is (and the loop broke) 

**Returns**: int: Index number of value in the List or where it should be if it exists.

---

# 121_best_time_to_buy_and_sell_stock.py

**File Name**: 121_best_time_to_buy_and_sell_stock.py

**Key Point**: Use two pointers. Left pointer tracks the lowest (buy) price. Right pointer always iterates. 

**Link**: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ 

**Method**: Start buy_pointer at the first index and sell_pointer at the second index. At each loop, calculate the current value (sell value - buy value). Memorize new max values. If buy pointer is > sell pointer, it should be moved. Sell pointer holds the current lowest value. Sell pointer should iterate at each loop (as if days are moving foward). 

**Returns**: int: Maximum difference between a sell value and buy value in the list of prices.

---

# 206_reverse_linked_list.py

**File Name**: 206_reverse_linked_list.py

**Key Point**: Current, next and prev hold the structure of the linked list as you are reversing the direction of the pointers. 

**Link**: https://leetcode.com/problems/reverse-linked-list/ 

**Method**: Current, next and prev hold the structure of the linked list as you are reversing the direction of the pointers. 

**Returns**: ListNode: Head of the reversed linked list.

---

# 704_binary_search.py

**File Name**: 704_binary_search.py

**Key Point**: Cut the breadth of the search area in half at every iteration. 

**Link**: https://leetcode.com/problems/binary-search/ 

**Method**: At each iteration of the loop, calculate a pivot (midpoint) that is between the two endpoints. Initially, the endpoints are the ends of the array. If the midpoint is larger than the target, then the next search area is the lower half of the array (and upper half if it is larger). This repeats until the value is found or the array is exhausted. 

**Returns**: int: index of the target number or -1 if it is not found.

---

