# Leetcode DocStrings

This README file was autogenerated with readme_generator.py.

# Contents
- [0001_two_sum](#0001_two_sumpy)
- [0020_valid_parenthesis](#0020_valid_parenthesispy)
- [0021_merge_two_sorted_lists](#0021_merge_two_sorted_listspy)
- [0035_search_insert_position](#0035_search_insert_positionpy)
- [0104_maximum_depth_of_binary_tree](#0104_maximum_depth_of_binary_treepy)
- [0111_minimum_depth_of_binary_tree](#0111_minimum_depth_of_binary_treepy)
- [0112_path_sum](#0112_path_sumpy)
- [0121_best_time_to_buy_and_sell_stock](#0121_best_time_to_buy_and_sell_stockpy)
- [0206_reverse_linked_list](#0206_reverse_linked_listpy)
- [0219_container_duplicate_ii](#0219_container_duplicate_iipy)
- [0226_invert_binary_tree](#0226_invert_binary_treepy)
- [0270_closest_binary_search_tree_value](#0270_closest_binary_search_tree_valuepy)
- [0344_reverse_string](#0344_reverse_stringpy)
- [0530_minimum_absolute_difference_in_BST](#0530_minimum_absolute_difference_in_BSTpy)
- [0543_diameter_of_a_binary_tree](#0543_diameter_of_a_binary_treepy)
- [0643_maximum_average_subarray_i](#0643_maximum_average_subarray_ipy)
- [0701_insert_into_binary_tree](#0701_insert_into_binary_treepy)
- [0704_binary_search](#0704_binary_searchpy)
- [0938_range_sum_of_BST](#0938_range_sum_of_BSTpy)
- [0977_squares_of_a_sorted_array](#0977_squares_of_a_sorted_arraypy)
- [1971_find_if_path_exists_in_graph](#1971_find_if_path_exists_in_graphpy)

# 0001_two_sum.py

**File Name**: 0001_two_sum.py

**Key Point**: Use dictionary (hash map) to store results. 

**Link**: [two sum](https://leetcode.com/problems/two-sum/ )

**Method**: Iterates through the list. If (target - current_value) is not in the dictionary, we append its value and index. If it is in the dictionary, we can return the indicies of target and current_value. This is because its presence in the dictionary lets us know that we have already encountered and logged the second number necessary to reach the target value. 

**Returns**: List: [index1, index2] where nums[index1] + nums[index2] == target


[Return to Top](#contents)

---

# 0020_valid_parenthesis.py

**File Name**: 0020_valid_parenthesis.py

**Key Point**: Use a stack to store opening brackets. Pop to compare them to closing brackets. 

**Link**: [valid parenthesis](https://leetcode.com/problems/valid-parentheses/ )

**Method**: I chose to build a pattern dictionary to represent valid pairs of brackets. Opening brackets (dict keys) are push onto a stack. When a closing bracket is encountered, the stack is popped. The value of dict[opening_bracket] is compared to the encountered closing bracket. If there is a mismatch, then the function returns False. 

**Returns**: bool: True if string contains brackets in correct order. False if not.


[Return to Top](#contents)

---

# 0021_merge_two_sorted_lists.py

**File Name**: 0021_merge_two_sorted_lists.py

**Key Point**: Account for ragged edges (uneven lists). 

**Link**: [merge two sorted lists](https://leetcode.com/problems/merge-two-sorted-lists/ )

**Method**: Most of the logic is used to account for uneven lists. If either list is missing, the remaining is immediately returned. This method recursively compares each node from one list against the other. The until the base case (at least one null list) is reached. At each method call, the smaller of either node (or node from list1 if equal) is ultimately returned. 

**Returns**: ListNode: Head of merged List.


[Return to Top](#contents)

---

# 0035_search_insert_position.py

**File Name**: 0035_search_insert_position.py

**Key Point**: This is a binary search that estimates the index of a missing value rather than returning -1. 

**Link**: [search insert position](https://leetcode.com/problems/search-insert-position/ )

**Method**: Binary search algorithm. However, if the value is not found: 1) Midpoint is the last one calculated when start_index = end_index. 2) If the midpoint is < target, it means that the target should be in the next sequential index (start_index in my implementation). 3) Otherwise, it should be where the midpoint is (and the loop broke) 

**Returns**: int: Index number of value in the List or where it should be if it exists.


[Return to Top](#contents)

---

# 0104_maximum_depth_of_binary_tree.py

**File Name**: 0104_maximum_depth_of_binary_tree.py

**Key Point**: Use recursive DFS to get the max depth. 

**Link**: [maximum depth of binary tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/ )

**Method**: Recursive method. Starting at root, count each existing node until the furthest node is reached. Each recursive method call will only return the highest current count (1 or 0). All counts return up through the call stack. 

**Returns**: Int: Max depth of tree


[Return to Top](#contents)

---

# 0111_minimum_depth_of_binary_tree.py

**File Name**: 0111_minimum_depth_of_binary_tree.py

**Key Point**:  Key point: Used DFS to traverse all nodes. 

**Link**: [minimum depth of binary tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/ )

**Method**: Use DFS to reach each leaf node. Track the current depth of each level as you traverse down. Once you reach the leaf, return the values back up the stack. Keep the min of the left and right subtrees at each node. 

**Returns**: int of the minimum depth from root to a leaf node.


[Return to Top](#contents)

---

# 0112_path_sum.py

**File Name**: 0112_path_sum.py

**Key Point**:  Target sum must be 0 at a leaf node for path sum to exist. 

**Link**: [path sum](https://leetcode.com/problems/path-sum/description/ )

**Method**: Traverse each path from root to node, subtracting the value of the node from the targetSum at each traversal. If the value is 0 at the leaf node, then the sum of the path adds exactly to the target sum. 

**Returns**: True if path sum exists or False otherwise.


[Return to Top](#contents)

---

# 0121_best_time_to_buy_and_sell_stock.py

**File Name**: 0121_best_time_to_buy_and_sell_stock.py

**Key Point**: Use two pointers. Left pointer tracks the lowest (buy) price. Right pointer always iterates. 

**Link**: [best time to buy and sell stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ )

**Method**: Start buy_pointer at the first index and sell_pointer at the second index. At each loop, calculate the current value (sell value - buy value). Memorize new max values. If buy pointer is > sell pointer, it should be moved. Sell pointer holds the current lowest value. Sell pointer should iterate at each loop (as if days are moving foward). 

**Returns**: int: Maximum difference between a sell value and buy value in the list of prices.


[Return to Top](#contents)

---

# 0206_reverse_linked_list.py

**File Name**: 0206_reverse_linked_list.py

**Key Point**: Current, next and prev hold the structure of the linked list as you are reversing the direction of the pointers. 

**Link**: [reverse linked list](https://leetcode.com/problems/reverse-linked-list/ )

**Method**: Current, next and prev hold the structure of the linked list as you are reversing the direction of the pointers. 

**Returns**: ListNode: Head of the reversed linked list.


[Return to Top](#contents)

---

# 0219_container_duplicate_ii.py

**File Name**: 0219_container_duplicate_ii.py

**Key Point**:  Use hash map to track encountered numbers. 

**Link**: [container duplicate ii](https://leetcode.com/problems/contains-duplicate-ii/ )

**Method**: Probably not necessary to use Deque and popleft. Track encountered numbers in a dictionary with value being the index. When the same value is encountered again, calculate: abs(curr_index - last_index). Return true if <= k. 

**Returns**: True if there is a duplicate matching the reqs and False if not.


[Return to Top](#contents)

---

# 0226_invert_binary_tree.py

**File Name**: 0226_invert_binary_tree.py

**Key Point**: Use a temp node to swap left and right nodes. 

**Link**: [invert binary tree](https://leetcode.com/problems/invert-binary-tree/submissions/ )

**Method**: Recursive method. For each node, return if its None. Else, swap the left and right nodes. Then call invert on the child nodes. 

**Returns**: Optional[TreeNode]: Head of inverted binary tree.


[Return to Top](#contents)

---

# 0270_closest_binary_search_tree_value.py

**File Name**: 0270_closest_binary_search_tree_value.py

**Key Point**:  Use the property of inorder traversal to build a sorted list. 

**Link**: [closest binary search tree value](https://leetcode.com/problems/closest-binary-search-tree-value/ )

**Method**: Build an sorted list through inorder DFS traversal. Then calculate the distance between the target and current value per element of the list, returning the element with the smallest distance. 

**Returns**: The node value closest to the target number.


[Return to Top](#contents)

---

# 0344_reverse_string.py

**File Name**: 0344_reverse_string.py

**Key Point**:  Can either use stack or two pointers. Two pointers uses less memory. 

**Link**: [reverse string](https://leetcode.com/problems/reverse-string/ )

**Method**: Swap letters at both ends until pointers meet. 

**Returns**: Nothing. In place swap.


[Return to Top](#contents)

---

# 0530_minimum_absolute_difference_in_BST.py

**File Name**: 0530_minimum_absolute_difference_in_BST.py

**Key Point**:  Note that inorder traversal using DFS on a BST will allow you to perform operations on each node in sorted, ascending order. 

**Link**: [minimum absolute difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/ )

**Method**: Use inorder DFS traversal to get a sorted list of node values and then find the minimum between two values. 

**Returns**: An int representing the minimum difference between the values of two nodes or -1 if the root is None.


[Return to Top](#contents)

---

# 0543_diameter_of_a_binary_tree.py

**File Name**: 0543_diameter_of_a_binary_tree.py

**Key Point**:  Key point: Add the longest path on the left side with the longest path on the right side to find the total longest path. 

**Link**: [diameter of a binary tree](https://leetcode.com/problems/diameter-of-binary-tree/description/ )

**Method**: Use DFS to traverse the tree recursively. Imagine you start at the leaf. Each leaf is a length of 1. The parent above the leaf is a length of 2 (child node + 1). Taking the max of this & bubbling up to root will return the longest unbroken path on a given side. Adding paths from both sides will then give the longest path between 2 nodes. 

**Returns**: int representing the longest distance between 2 nodes or 0 if the root is None.


[Return to Top](#contents)

---

# 0643_maximum_average_subarray_i.py

**File Name**: 0643_maximum_average_subarray_i.py

**Key Point**:  Sliding window problem with fixed width "k". Maintain moving average. 

**Link**: [maximum average subarray i](https://leetcode.com/problems/maximum-average-subarray-i/ )

**Method**: See Key Point. 

**Returns**: float of maximum average


[Return to Top](#contents)

---

# 0701_insert_into_binary_tree.py

**File Name**: 0701_insert_into_binary_tree.py

**Key Point**:  Add node without balancing BST. 

**Link**: [insert into binary tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/ )

**Method**: Use recursion to traverse to the end of the BST. Setting node.left & node.right to the value of the recursive call either maintains the existing structure or appends the node to a leaf. 

**Returns**: The root node of the BST or a node of passed val if the root is None.


[Return to Top](#contents)

---

# 0704_binary_search.py

**File Name**: 0704_binary_search.py

**Key Point**: Cut the breadth of the search area in half at every iteration. 

**Link**: [binary search](https://leetcode.com/problems/binary-search/ )

**Method**: At each iteration of the loop, calculate a pivot (midpoint) that is between the two endpoints. Initially, the endpoints are the ends of the array. If the midpoint is larger than the target, then the next search area is the lower half of the array (and upper half if it is larger). This repeats until the value is found or the array is exhausted. 

**Returns**: int: index of the target number or -1 if it is not found.


[Return to Top](#contents)

---

# 0938_range_sum_of_BST.py

**File Name**: 0938_range_sum_of_BST.py

**Key Point**:  Use the property of Binary Search Trees to include or exclude subtrees based on value of the current node. 

**Link**: [range sum of BST](https://leetcode.com/problems/range-sum-of-bst/description/ )

**Method**: Consider the property of BSTs. At a given node, if the node's value is <= the low watermark, then every node in the left subtree will be below the cutoff. If value is >= to the high watermark, then every node in the right subtree will be above the cutoff. 

**Returns**: Sum of all node values in an inclusive range or 0 if the root is None.


[Return to Top](#contents)

---

# 0977_squares_of_a_sorted_array.py

**File Name**: 0977_squares_of_a_sorted_array.py

**Key Point**:  Two pointers. Maintain sorted order by comparing absolute values. 

**Link**: [squares of a sorted array](https://leetcode.com/problems/squares-of-a-sorted-array/ )

**Method**: Left pointer at bottom and right pointer at top. Pointers move towards each other. Largest abs value is placed into the array from top down. This maintains sorted order if negatives are present. 

**Returns**: Sorted array of ints of increasing value.


[Return to Top](#contents)

---

# 1971_find_if_path_exists_in_graph.py

**File Name**: 1971_find_if_path_exists_in_graph.py

**Key Point**:  Use DFS to search the tree for the target node, starting at a given source node. 

**Link**: [find if path exists in graph](https://leetcode.com/problems/find-if-path-exists-in-graph/ )

**Method**: Build an adjacency list from the input. Start at the source node, and start to visit all connected nodes using DFS. Break and return True if the destination node is found. 

**Returns**: True if path exists from source node to destination node or False if not.


[Return to Top](#contents)

---

